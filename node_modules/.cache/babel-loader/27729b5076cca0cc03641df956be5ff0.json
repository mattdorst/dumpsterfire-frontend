{"ast":null,"code":"import BigNumber from 'bignumber.js/bignumber';\nimport ERC20Abi from './abi/erc20.json';\nimport MasterChefAbi from './abi/masterchef.json';\nimport SushiAbi from './abi/sushi.json';\nimport UNIV2PairAbi from './abi/uni_v2_lp.json';\nimport WETHAbi from './abi/weth.json';\nimport { contractAddresses, SUBTRACT_GAS_LIMIT, supportedPools } from './constants.js';\nimport * as Types from './types.js';\nexport class Contracts {\n  constructor(provider, networkId, web3, options) {\n    this.web3 = web3;\n    this.defaultConfirmations = options.defaultConfirmations;\n    this.autoGasMultiplier = options.autoGasMultiplier || 1.5;\n    this.confirmationType = options.confirmationType || Types.ConfirmationType.Confirmed;\n    this.defaultGas = options.defaultGas;\n    this.defaultGasPrice = options.defaultGasPrice;\n    this.sushi = new this.web3.eth.Contract(SushiAbi);\n    this.masterChef = new this.web3.eth.Contract(MasterChefAbi);\n    this.weth = new this.web3.eth.Contract(WETHAbi);\n    this.pools = supportedPools.map(pool => Object.assign(pool, {\n      lpAddress: pool.lpAddresses[networkId],\n      tokenAddress: pool.tokenAddresses[networkId],\n      lpContract: new this.web3.eth.Contract(UNIV2PairAbi),\n      tokenContract: new this.web3.eth.Contract(ERC20Abi)\n    }));\n    this.setProvider(provider, networkId);\n    this.setDefaultAccount(this.web3.eth.defaultAccount);\n  }\n\n  setProvider(provider, networkId) {\n    const setProvider = (contract, address) => {\n      contract.setProvider(provider);\n      if (address) contract.options.address = address;else console.error('Contract address not found in network', networkId);\n    };\n\n    setProvider(this.sushi, contractAddresses.sushi[networkId]);\n    setProvider(this.masterChef, contractAddresses.masterChef[networkId]);\n    setProvider(this.weth, contractAddresses.weth[networkId]);\n    this.pools.forEach(({\n      lpContract,\n      lpAddress,\n      tokenContract,\n      tokenAddress\n    }) => {\n      setProvider(lpContract, lpAddress);\n      setProvider(tokenContract, tokenAddress);\n    });\n  }\n\n  setDefaultAccount(account) {\n    this.sushi.options.from = account;\n    this.masterChef.options.from = account;\n  }\n\n  async callContractFunction(method, options) {\n    const {\n      confirmations,\n      confirmationType,\n      autoGasMultiplier,\n      ...txOptions\n    } = options;\n\n    if (!this.blockGasLimit) {\n      await this.setGasLimit();\n    }\n\n    if (!txOptions.gasPrice && this.defaultGasPrice) {\n      txOptions.gasPrice = this.defaultGasPrice;\n    }\n\n    if (confirmationType === Types.ConfirmationType.Simulate || !options.gas) {\n      let gasEstimate;\n\n      if (this.defaultGas && confirmationType !== Types.ConfirmationType.Simulate) {\n        txOptions.gas = this.defaultGas;\n      } else {\n        try {\n          console.log('estimating gas');\n          gasEstimate = await method.estimateGas(txOptions);\n        } catch (error) {\n          const data = method.encodeABI();\n          const {\n            from,\n            value\n          } = options;\n          const to = method._parent._address;\n          error.transactionData = {\n            from,\n            value,\n            data,\n            to\n          };\n          throw error;\n        }\n\n        const multiplier = autoGasMultiplier || this.autoGasMultiplier;\n        const totalGas = Math.floor(gasEstimate * multiplier);\n        txOptions.gas = totalGas < this.blockGasLimit ? totalGas : this.blockGasLimit;\n      }\n\n      if (confirmationType === Types.ConfirmationType.Simulate) {\n        let g = txOptions.gas;\n        return {\n          gasEstimate,\n          g\n        };\n      }\n    }\n\n    if (txOptions.value) {\n      txOptions.value = new BigNumber(txOptions.value).toFixed(0);\n    } else {\n      txOptions.value = '0';\n    }\n\n    const promi = method.send(txOptions);\n    const OUTCOMES = {\n      INITIAL: 0,\n      RESOLVED: 1,\n      REJECTED: 2\n    };\n    let hashOutcome = OUTCOMES.INITIAL;\n    let confirmationOutcome = OUTCOMES.INITIAL;\n    const t = confirmationType !== undefined ? confirmationType : this.confirmationType;\n\n    if (!Object.values(Types.ConfirmationType).includes(t)) {\n      throw new Error(`Invalid confirmation type: ${t}`);\n    }\n\n    let hashPromise;\n    let confirmationPromise;\n\n    if (t === Types.ConfirmationType.Hash || t === Types.ConfirmationType.Both) {\n      hashPromise = new Promise((resolve, reject) => {\n        promi.on('error', error => {\n          if (hashOutcome === OUTCOMES.INITIAL) {\n            hashOutcome = OUTCOMES.REJECTED;\n            reject(error);\n            const anyPromi = promi;\n            anyPromi.off();\n          }\n        });\n        promi.on('transactionHash', txHash => {\n          if (hashOutcome === OUTCOMES.INITIAL) {\n            hashOutcome = OUTCOMES.RESOLVED;\n            resolve(txHash);\n\n            if (t !== Types.ConfirmationType.Both) {\n              const anyPromi = promi;\n              anyPromi.off();\n            }\n          }\n        });\n      });\n    }\n\n    if (t === Types.ConfirmationType.Confirmed || t === Types.ConfirmationType.Both) {\n      confirmationPromise = new Promise((resolve, reject) => {\n        promi.on('error', error => {\n          if ((t === Types.ConfirmationType.Confirmed || hashOutcome === OUTCOMES.RESOLVED) && confirmationOutcome === OUTCOMES.INITIAL) {\n            confirmationOutcome = OUTCOMES.REJECTED;\n            reject(error);\n            const anyPromi = promi;\n            anyPromi.off();\n          }\n        });\n        const desiredConf = confirmations || this.defaultConfirmations;\n\n        if (desiredConf) {\n          promi.on('confirmation', (confNumber, receipt) => {\n            if (confNumber >= desiredConf) {\n              if (confirmationOutcome === OUTCOMES.INITIAL) {\n                confirmationOutcome = OUTCOMES.RESOLVED;\n                resolve(receipt);\n                const anyPromi = promi;\n                anyPromi.off();\n              }\n            }\n          });\n        } else {\n          promi.on('receipt', receipt => {\n            confirmationOutcome = OUTCOMES.RESOLVED;\n            resolve(receipt);\n            const anyPromi = promi;\n            anyPromi.off();\n          });\n        }\n      });\n    }\n\n    if (t === Types.ConfirmationType.Hash) {\n      const transactionHash = await hashPromise;\n\n      if (this.notifier) {\n        this.notifier.hash(transactionHash);\n      }\n\n      return {\n        transactionHash\n      };\n    }\n\n    if (t === Types.ConfirmationType.Confirmed) {\n      return confirmationPromise;\n    }\n\n    const transactionHash = await hashPromise;\n\n    if (this.notifier) {\n      this.notifier.hash(transactionHash);\n    }\n\n    return {\n      transactionHash,\n      confirmation: confirmationPromise\n    };\n  }\n\n  async callConstantContractFunction(method, options) {\n    const m2 = method;\n    const {\n      blockNumber,\n      ...txOptions\n    } = options;\n    return m2.call(txOptions, blockNumber);\n  }\n\n  async setGasLimit() {\n    const block = await this.web3.eth.getBlock('latest');\n    this.blockGasLimit = block.gasLimit - SUBTRACT_GAS_LIMIT;\n  }\n\n}","map":{"version":3,"sources":["/Users/matt/Projects/sushiswap-frontend/src/sushi/lib/contracts.js"],"names":["BigNumber","ERC20Abi","MasterChefAbi","SushiAbi","UNIV2PairAbi","WETHAbi","contractAddresses","SUBTRACT_GAS_LIMIT","supportedPools","Types","Contracts","constructor","provider","networkId","web3","options","defaultConfirmations","autoGasMultiplier","confirmationType","ConfirmationType","Confirmed","defaultGas","defaultGasPrice","sushi","eth","Contract","masterChef","weth","pools","map","pool","Object","assign","lpAddress","lpAddresses","tokenAddress","tokenAddresses","lpContract","tokenContract","setProvider","setDefaultAccount","defaultAccount","contract","address","console","error","forEach","account","from","callContractFunction","method","confirmations","txOptions","blockGasLimit","setGasLimit","gasPrice","Simulate","gas","gasEstimate","log","estimateGas","data","encodeABI","value","to","_parent","_address","transactionData","multiplier","totalGas","Math","floor","g","toFixed","promi","send","OUTCOMES","INITIAL","RESOLVED","REJECTED","hashOutcome","confirmationOutcome","t","undefined","values","includes","Error","hashPromise","confirmationPromise","Hash","Both","Promise","resolve","reject","on","anyPromi","off","txHash","desiredConf","confNumber","receipt","transactionHash","notifier","hash","confirmation","callConstantContractFunction","m2","blockNumber","call","block","getBlock","gasLimit"],"mappings":"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","sourcesContent":["import BigNumber from 'bignumber.js/bignumber'\nimport ERC20Abi from './abi/erc20.json'\nimport MasterChefAbi from './abi/masterchef.json'\nimport SushiAbi from './abi/sushi.json'\nimport UNIV2PairAbi from './abi/uni_v2_lp.json'\nimport WETHAbi from './abi/weth.json'\nimport {\n  contractAddresses,\n  SUBTRACT_GAS_LIMIT,\n  supportedPools,\n} from './constants.js'\nimport * as Types from './types.js'\n\nexport class Contracts {\n  constructor(provider, networkId, web3, options) {\n    this.web3 = web3\n    this.defaultConfirmations = options.defaultConfirmations\n    this.autoGasMultiplier = options.autoGasMultiplier || 1.5\n    this.confirmationType =\n      options.confirmationType || Types.ConfirmationType.Confirmed\n    this.defaultGas = options.defaultGas\n    this.defaultGasPrice = options.defaultGasPrice\n\n    this.sushi = new this.web3.eth.Contract(SushiAbi)\n    this.masterChef = new this.web3.eth.Contract(MasterChefAbi)\n    this.weth = new this.web3.eth.Contract(WETHAbi)\n\n    this.pools = supportedPools.map((pool) =>\n      Object.assign(pool, {\n        lpAddress: pool.lpAddresses[networkId],\n        tokenAddress: pool.tokenAddresses[networkId],\n        lpContract: new this.web3.eth.Contract(UNIV2PairAbi),\n        tokenContract: new this.web3.eth.Contract(ERC20Abi),\n      }),\n    )\n\n    this.setProvider(provider, networkId)\n    this.setDefaultAccount(this.web3.eth.defaultAccount)\n  }\n\n  setProvider(provider, networkId) {\n    const setProvider = (contract, address) => {\n      contract.setProvider(provider)\n      if (address) contract.options.address = address\n      else console.error('Contract address not found in network', networkId)\n    }\n\n    setProvider(this.sushi, contractAddresses.sushi[networkId])\n    setProvider(this.masterChef, contractAddresses.masterChef[networkId])\n    setProvider(this.weth, contractAddresses.weth[networkId])\n\n    this.pools.forEach(\n      ({ lpContract, lpAddress, tokenContract, tokenAddress }) => {\n        setProvider(lpContract, lpAddress)\n        setProvider(tokenContract, tokenAddress)\n      },\n    )\n  }\n\n  setDefaultAccount(account) {\n    this.sushi.options.from = account\n    this.masterChef.options.from = account\n  }\n\n  async callContractFunction(method, options) {\n    const {\n      confirmations,\n      confirmationType,\n      autoGasMultiplier,\n      ...txOptions\n    } = options\n\n    if (!this.blockGasLimit) {\n      await this.setGasLimit()\n    }\n\n    if (!txOptions.gasPrice && this.defaultGasPrice) {\n      txOptions.gasPrice = this.defaultGasPrice\n    }\n\n    if (confirmationType === Types.ConfirmationType.Simulate || !options.gas) {\n      let gasEstimate\n      if (\n        this.defaultGas &&\n        confirmationType !== Types.ConfirmationType.Simulate\n      ) {\n        txOptions.gas = this.defaultGas\n      } else {\n        try {\n          console.log('estimating gas')\n          gasEstimate = await method.estimateGas(txOptions)\n        } catch (error) {\n          const data = method.encodeABI()\n          const { from, value } = options\n          const to = method._parent._address\n          error.transactionData = { from, value, data, to }\n          throw error\n        }\n\n        const multiplier = autoGasMultiplier || this.autoGasMultiplier\n        const totalGas = Math.floor(gasEstimate * multiplier)\n        txOptions.gas =\n          totalGas < this.blockGasLimit ? totalGas : this.blockGasLimit\n      }\n\n      if (confirmationType === Types.ConfirmationType.Simulate) {\n        let g = txOptions.gas\n        return { gasEstimate, g }\n      }\n    }\n\n    if (txOptions.value) {\n      txOptions.value = new BigNumber(txOptions.value).toFixed(0)\n    } else {\n      txOptions.value = '0'\n    }\n\n    const promi = method.send(txOptions)\n\n    const OUTCOMES = {\n      INITIAL: 0,\n      RESOLVED: 1,\n      REJECTED: 2,\n    }\n\n    let hashOutcome = OUTCOMES.INITIAL\n    let confirmationOutcome = OUTCOMES.INITIAL\n\n    const t =\n      confirmationType !== undefined ? confirmationType : this.confirmationType\n\n    if (!Object.values(Types.ConfirmationType).includes(t)) {\n      throw new Error(`Invalid confirmation type: ${t}`)\n    }\n\n    let hashPromise\n    let confirmationPromise\n\n    if (\n      t === Types.ConfirmationType.Hash ||\n      t === Types.ConfirmationType.Both\n    ) {\n      hashPromise = new Promise((resolve, reject) => {\n        promi.on('error', (error) => {\n          if (hashOutcome === OUTCOMES.INITIAL) {\n            hashOutcome = OUTCOMES.REJECTED\n            reject(error)\n            const anyPromi = promi\n            anyPromi.off()\n          }\n        })\n\n        promi.on('transactionHash', (txHash) => {\n          if (hashOutcome === OUTCOMES.INITIAL) {\n            hashOutcome = OUTCOMES.RESOLVED\n            resolve(txHash)\n            if (t !== Types.ConfirmationType.Both) {\n              const anyPromi = promi\n              anyPromi.off()\n            }\n          }\n        })\n      })\n    }\n\n    if (\n      t === Types.ConfirmationType.Confirmed ||\n      t === Types.ConfirmationType.Both\n    ) {\n      confirmationPromise = new Promise((resolve, reject) => {\n        promi.on('error', (error) => {\n          if (\n            (t === Types.ConfirmationType.Confirmed ||\n              hashOutcome === OUTCOMES.RESOLVED) &&\n            confirmationOutcome === OUTCOMES.INITIAL\n          ) {\n            confirmationOutcome = OUTCOMES.REJECTED\n            reject(error)\n            const anyPromi = promi\n            anyPromi.off()\n          }\n        })\n\n        const desiredConf = confirmations || this.defaultConfirmations\n        if (desiredConf) {\n          promi.on('confirmation', (confNumber, receipt) => {\n            if (confNumber >= desiredConf) {\n              if (confirmationOutcome === OUTCOMES.INITIAL) {\n                confirmationOutcome = OUTCOMES.RESOLVED\n                resolve(receipt)\n                const anyPromi = promi\n                anyPromi.off()\n              }\n            }\n          })\n        } else {\n          promi.on('receipt', (receipt) => {\n            confirmationOutcome = OUTCOMES.RESOLVED\n            resolve(receipt)\n            const anyPromi = promi\n            anyPromi.off()\n          })\n        }\n      })\n    }\n\n    if (t === Types.ConfirmationType.Hash) {\n      const transactionHash = await hashPromise\n      if (this.notifier) {\n        this.notifier.hash(transactionHash)\n      }\n      return { transactionHash }\n    }\n\n    if (t === Types.ConfirmationType.Confirmed) {\n      return confirmationPromise\n    }\n\n    const transactionHash = await hashPromise\n    if (this.notifier) {\n      this.notifier.hash(transactionHash)\n    }\n    return {\n      transactionHash,\n      confirmation: confirmationPromise,\n    }\n  }\n\n  async callConstantContractFunction(method, options) {\n    const m2 = method\n    const { blockNumber, ...txOptions } = options\n    return m2.call(txOptions, blockNumber)\n  }\n\n  async setGasLimit() {\n    const block = await this.web3.eth.getBlock('latest')\n    this.blockGasLimit = block.gasLimit - SUBTRACT_GAS_LIMIT\n  }\n}\n"]},"metadata":{},"sourceType":"module"}